#class std::tuple<class std::basic_string<char32_t,struct std::char_traits<char32_t>,class std::allocator<char32_t> >,class std::vector<class std::tuple<int,class std::optional<struct std::pair<char32_t,unsigned __int64> >,class std::expected<struct std::pair<char32_t,unsigned __int64>,class std::basic_string<char8_t,struct std::char_traits<char8_t>,class std::allocator<char8_t> > > >,class std::allocator<class std::tuple<int,class std::optional<struct std::pair<char32_t,unsigned __int64> >,class std::expected<struct std::pair<char32_t,unsigned __int64>,class std::basic_string<char8_t,struct std::char_traits<char8_t>,class std::allocator<char8_t> > > > > > >
("hello\x0000D800",[(0,(0,('h',1))),(2,(0,('l',1))),(5,(1,"The function next_char32_t was unable to get the next UTF32 code point from the unicide substring \"\\x0000D800\". This substring has been created using the iterator arguments for next_char32_t. next_char32_t was unable to get the next UF32 code point due to the following reason; the 1st char32_t code unit in the unicode substring, represented in hex as 0x0000D800, was found to be invalid under the UTF32 standard. UTF32 code units must be inclusively between either 0x00000000 and 0x0000D7FF, or 0x0000E000 and 0x0010FFFF. Therefore, the code unit 0x0000D800 is invalid."))])
