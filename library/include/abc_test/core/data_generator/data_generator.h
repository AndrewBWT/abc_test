#pragma once
#include "abc_test/core/ds/data_generator_memoization/data_generator_memoized_element.h"
#include "abc_test/core/ds/data_generator_memoization/indexed_data_generator_collection_memoized_element.h"
#include "abc_test/core/ds/type_synonyms.h"
#include "abc_test/core/global.h"
#include "abc_test/utility/io/file/file_name.h"
#include "abc_test/utility/io/file/file_reader.h"
#include "abc_test/utility/io/file/file_rw.h"
#include "abc_test/utility/io/file/file_writer.h"

#include <expected>
#include <functional>
#include <memory>
#include <optional>
#include <scn/scan.h>
#include <string>
#include <vector>

_BEGIN_ABC_NS

/*!
 * @brief This abstract class represents the data generator; a mechanism used in
 * abc_test to generate data in manner which is useful when writing tests.
 *
 * data_generator_t allows the user to write loops which output data. By using
 * this abstract class, the user can easily add the ability for the generators
 * to read and write data to a file, and when the user wants to repeat tests but
 * only generate data which has resulted in a failure previously, this class can
 * be used to achieve that aim with little to no additional input from the user.
 *
 * @tparam T The output type from the generator.
 */
template <typename T>
struct data_generator_t
{
public:
    /*!
     * @brief Default constructor.
     */
    __constexpr
    data_generator_t() noexcept
        = delete;
    __constexpr
    data_generator_t(const std::size_t _a_mode) noexcept;
    /*!
     * @brief Gets the mode of the object.
     * @return The mode.
     */
    __constexpr std::size_t
                mode() const noexcept;
    /*!
     * @brief Tells the caller whether the object has a current element.
     *
     * By current element, we mean that calling current_element() will return an
     * element which is well-formed.
     * @return True if there is a current element. False otherwise.
     */
    __constexpr virtual bool
        has_current_element() const
        = 0;
    /*!
     * @brief Returns a cref to the current element's caller.
     * @return A cref to the object's current element.
     */
    __constexpr virtual const T&
        current_element() const
        = 0;
    /*!
     * @brief Generates the next element in the generator.
     * @return True if the data_generator_t was able to generate a next entity;
     * false otherwise.
     */
    __constexpr virtual bool
        generate_next()
        = 0;
    /*!
     * @brief Sets the data_generator using the
     * data_generator_memoized_element_t argument.
     *
     * This function should set the state of the object to the exact state the
     * data_generator_t would be if it had got to this state organicly.
     *
     * @param _a_dgme The data_generator_memoized_element_t to set the object
     * to.
     */
    __constexpr virtual void
        set_data_generator_using_data_generator_memoized_element(
            const ds::dg_memoized_element_t& _a_dgme
        )
        = 0;
    /*!
     * @brief This function returns the dg_memoized_element_t to the caller
     * which represents this object.
     *
     * Care must be taken when defining this object as it has two modes.
     *
     * When _a_get_data_for_repeating is true, this function gets the
     * ds::dg_memoized_element_t with its data from memoized sources if
     * available.
     *
     * What this means is that, if we have generated some data A which, on
     * failure, is written to a file F. When
     * get_data_generator_memoized_element(true) is called, this function should
     * return the dg_memoized_element_t with data from the file.
     *
     * When _a_get_data_for_repeating is false, return the data used as if it
     * were generated. This may still be from a file, but it was originally from
     * a file (atleast on this run).
     *
     * @param _a_get_data_for_repeating Denotes whether to get the data from any
     * alternative source or the original source.
     * @return a ds::dg_memoized_element_t object representing the data
     * generated by this data_generator_t.
     */
    __constexpr virtual ds::dg_memoized_element_t
        get_data_generator_memoized_element(const bool _a_get_data_for_repeating
        ) const noexcept
        = 0;
    /*!
     * @brief Gets the caller a string representation of the data used to create
     * the instance current_element() points at.
     * @return String representative of the internal data of this object.
     */
    __constexpr virtual std::string
        get_additional_data() const
        = 0;
protected:
    std::size_t _m_mode = 0;
};

/*!
 * @brief Type synonym for a pointer to a data_generator_t element.
 * @tparam T The type param of the data_generator_t element.
 */
template <typename T>
using data_generator_ptr_t = std::shared_ptr<data_generator_t<T>>;

/*!
 * @brief Functino used to uniform errors::test_library_exception_t error for
 * when a mode is not supproted in a data_generator_t object.
 * @param _a_type_info The type_info of the element which called this function.
 * @param _a_mode The mode of the object which called this function.
 * @param _a_supported_elements The supported modes of the object which called
 * this function.
 * @return A errors::test_library_exception_t error object.
 */
__no_constexpr errors::test_library_exception_t
               unsupported_mode_exception(
                   const std::type_info&                     _a_type_info,
                   const std::size_t                         _a_mode,
                   const std::initializer_list<std::size_t>& _a_supported_elements
               );
_END_ABC_NS

_BEGIN_ABC_NS

template <typename T>
__constexpr_imp
    data_generator_t<T>::data_generator_t(
        const std::size_t _a_mode
    ) noexcept
    : _m_mode(_a_mode)
{}

template <typename T>
__constexpr_imp std::size_t
                data_generator_t<T>::mode() const noexcept
{
    return _m_mode;
}

__no_constexpr_imp errors::test_library_exception_t
                   unsupported_mode_exception(
                       const std::type_info&                     _a_type_info,
                       const std::size_t                         _a_mode,
                       const std::initializer_list<std::size_t>& _a_supported_elements
                   )
{
    using namespace errors;
    return test_library_exception_t(fmt::format(
        "{0} does not support mode {1}. {0} only supports the following modes: "
        "{2}",
        _a_type_info.name(),
        _a_mode,
        _a_supported_elements
    ));
}

_END_ABC_NS